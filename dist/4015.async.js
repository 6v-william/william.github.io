"use strict";(self.webpackChunkpc_template=self.webpackChunkpc_template||[]).push([[4015],{87609:function(D,n){Object.defineProperty(n,"__esModule",{value:!0}),n.toBig=n.shrSL=n.shrSH=n.rotrSL=n.rotrSH=n.rotrBL=n.rotrBH=n.rotr32L=n.rotr32H=n.rotlSL=n.rotlSH=n.rotlBL=n.rotlBH=n.add5L=n.add5H=n.add4L=n.add4H=n.add3L=n.add3H=void 0,n.add=X,n.fromBig=l,n.split=A;const O=BigInt(2**32-1),_=BigInt(32);function l(i,r=!1){return r?{h:Number(i&O),l:Number(i>>_&O)}:{h:Number(i>>_&O)|0,l:Number(i&O)|0}}function A(i,r=!1){const e=i.length;let a=new Uint32Array(e),w=new Uint32Array(e);for(let k=0;k<e;k++){const{h:B,l:V}=l(i[k],r);[a[k],w[k]]=[B,V]}return[a,w]}const b=(i,r)=>BigInt(i>>>0)<<_|BigInt(r>>>0);n.toBig=b;const j=(i,r,e)=>i>>>e;n.shrSH=j;const v=(i,r,e)=>i<<32-e|r>>>e;n.shrSL=v;const M=(i,r,e)=>i>>>e|r<<32-e;n.rotrSH=M;const P=(i,r,e)=>i<<32-e|r>>>e;n.rotrSL=P;const T=(i,r,e)=>i<<64-e|r>>>e-32;n.rotrBH=T;const U=(i,r,e)=>i>>>e-32|r<<64-e;n.rotrBL=U;const p=(i,r)=>r;n.rotr32H=p;const F=(i,r)=>i;n.rotr32L=F;const C=(i,r,e)=>i<<e|r>>>32-e;n.rotlSH=C;const m=(i,r,e)=>r<<e|i>>>32-e;n.rotlSL=m;const I=(i,r,e)=>r<<e-32|i>>>64-e;n.rotlBH=I;const S=(i,r,e)=>i<<e-32|r>>>64-e;n.rotlBL=S;function X(i,r,e,a){const w=(r>>>0)+(a>>>0);return{h:i+e+(w/2**32|0)|0,l:w|0}}const H=(i,r,e)=>(i>>>0)+(r>>>0)+(e>>>0);n.add3L=H;const y=(i,r,e,a)=>r+e+a+(i/2**32|0)|0;n.add3H=y;const E=(i,r,e,a)=>(i>>>0)+(r>>>0)+(e>>>0)+(a>>>0);n.add4L=E;const s=(i,r,e,a,w)=>r+e+a+w+(i/2**32|0)|0;n.add4H=s;const o=(i,r,e,a,w)=>(i>>>0)+(r>>>0)+(e>>>0)+(a>>>0)+(w>>>0);n.add5L=o;const u=(i,r,e,a,w,k)=>r+e+a+w+k+(i/2**32|0)|0;n.add5H=u;const f={fromBig:l,split:A,toBig:b,shrSH:j,shrSL:v,rotrSH:M,rotrSL:P,rotrBH:T,rotrBL:U,rotr32H:p,rotr32L:F,rotlSH:C,rotlSL:m,rotlBH:I,rotlBL:S,add:X,add3L:H,add3H:y,add4L:E,add4H:s,add5H:u,add5L:o};n.default=f},47219:function(D,n){Object.defineProperty(n,"__esModule",{value:!0}),n.crypto=void 0,n.crypto=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0},54015:function(D,n,O){Object.defineProperty(n,"__esModule",{value:!0}),n.shake256=n.shake128=n.keccak_512=n.keccak_384=n.keccak_256=n.keccak_224=n.sha3_512=n.sha3_384=n.sha3_256=n.sha3_224=n.Keccak=void 0,n.keccakP=X;const _=O(87609),l=O(24027),A=BigInt(0),b=BigInt(1),j=BigInt(2),v=BigInt(7),M=BigInt(256),P=BigInt(113),T=[],U=[],p=[];for(let s=0,o=b,u=1,f=0;s<24;s++){[u,f]=[f,(2*u+3*f)%5],T.push(2*(5*f+u)),U.push((s+1)*(s+2)/2%64);let i=A;for(let r=0;r<7;r++)o=(o<<b^(o>>v)*P)%M,o&j&&(i^=b<<(b<<BigInt(r))-b);p.push(i)}const F=(0,_.split)(p,!0),C=F[0],m=F[1],I=(s,o,u)=>u>32?(0,_.rotlBH)(s,o,u):(0,_.rotlSH)(s,o,u),S=(s,o,u)=>u>32?(0,_.rotlBL)(s,o,u):(0,_.rotlSL)(s,o,u);function X(s,o=24){const u=new Uint32Array(10);for(let f=24-o;f<24;f++){for(let e=0;e<10;e++)u[e]=s[e]^s[e+10]^s[e+20]^s[e+30]^s[e+40];for(let e=0;e<10;e+=2){const a=(e+8)%10,w=(e+2)%10,k=u[w],B=u[w+1],V=I(k,B,1)^u[a],R=S(k,B,1)^u[a+1];for(let N=0;N<50;N+=10)s[e+N]^=V,s[e+N+1]^=R}let i=s[2],r=s[3];for(let e=0;e<24;e++){const a=U[e],w=I(i,r,a),k=S(i,r,a),B=T[e];i=s[B],r=s[B+1],s[B]=w,s[B+1]=k}for(let e=0;e<50;e+=10){for(let a=0;a<10;a++)u[a]=s[e+a];for(let a=0;a<10;a++)s[e+a]^=~u[(a+2)%10]&u[(a+4)%10]}s[0]^=C[f],s[1]^=m[f]}(0,l.clean)(u)}class H extends l.Hash{constructor(o,u,f,i=!1,r=24){if(super(),this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,this.enableXOF=!1,this.blockLen=o,this.suffix=u,this.outputLen=f,this.enableXOF=i,this.rounds=r,(0,l.anumber)(f),!(0<o&&o<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=(0,l.u32)(this.state)}clone(){return this._cloneInto()}keccak(){(0,l.swap32IfBE)(this.state32),X(this.state32,this.rounds),(0,l.swap32IfBE)(this.state32),this.posOut=0,this.pos=0}update(o){(0,l.aexists)(this),o=(0,l.toBytes)(o),(0,l.abytes)(o);const{blockLen:u,state:f}=this,i=o.length;for(let r=0;r<i;){const e=Math.min(u-this.pos,i-r);for(let a=0;a<e;a++)f[this.pos++]^=o[r++];this.pos===u&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:o,suffix:u,pos:f,blockLen:i}=this;o[f]^=u,u&128&&f===i-1&&this.keccak(),o[i-1]^=128,this.keccak()}writeInto(o){(0,l.aexists)(this,!1),(0,l.abytes)(o),this.finish();const u=this.state,{blockLen:f}=this;for(let i=0,r=o.length;i<r;){this.posOut>=f&&this.keccak();const e=Math.min(f-this.posOut,r-i);o.set(u.subarray(this.posOut,this.posOut+e),i),this.posOut+=e,i+=e}return o}xofInto(o){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(o)}xof(o){return(0,l.anumber)(o),this.xofInto(new Uint8Array(o))}digestInto(o){if((0,l.aoutput)(o,this),this.finished)throw new Error("digest() was already called");return this.writeInto(o),this.destroy(),o}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,(0,l.clean)(this.state)}_cloneInto(o){const{blockLen:u,suffix:f,outputLen:i,rounds:r,enableXOF:e}=this;return o||(o=new H(u,f,i,e,r)),o.state32.set(this.state32),o.pos=this.pos,o.posOut=this.posOut,o.finished=this.finished,o.rounds=r,o.suffix=f,o.outputLen=i,o.enableXOF=e,o.destroyed=this.destroyed,o}}n.Keccak=H;const y=(s,o,u)=>(0,l.createHasher)(()=>new H(o,s,u));n.sha3_224=(()=>y(6,144,224/8))(),n.sha3_256=(()=>y(6,136,256/8))(),n.sha3_384=(()=>y(6,104,384/8))(),n.sha3_512=(()=>y(6,72,512/8))(),n.keccak_224=(()=>y(1,144,224/8))(),n.keccak_256=(()=>y(1,136,256/8))(),n.keccak_384=(()=>y(1,104,384/8))(),n.keccak_512=(()=>y(1,72,512/8))();const E=(s,o,u)=>(0,l.createXOFer)((f={})=>new H(o,s,f.dkLen===void 0?u:f.dkLen,!0));n.shake128=(()=>E(31,168,128/8))(),n.shake256=(()=>E(31,136,256/8))()},24027:function(D,n,O){Object.defineProperty(n,"__esModule",{value:!0}),n.wrapXOFConstructorWithOpts=n.wrapConstructorWithOpts=n.wrapConstructor=n.Hash=n.nextTick=n.swap32IfBE=n.byteSwapIfBE=n.swap8IfBE=n.isLE=void 0,n.isBytes=l,n.anumber=A,n.abytes=b,n.ahash=j,n.aexists=v,n.aoutput=M,n.u8=P,n.u32=T,n.clean=U,n.createView=p,n.rotr=F,n.rotl=C,n.byteSwap=m,n.byteSwap32=I,n.bytesToHex=H,n.hexToBytes=s,n.asyncLoop=u,n.utf8ToBytes=f,n.bytesToUtf8=i,n.toBytes=r,n.kdfInputToBytes=e,n.concatBytes=a,n.checkOpts=w,n.createHasher=B,n.createOptHasher=V,n.createXOFer=R,n.randomBytes=N;const _=O(47219);function l(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function A(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function b(t,...c){if(!l(t))throw new Error("Uint8Array expected");if(c.length>0&&!c.includes(t.length))throw new Error("Uint8Array expected of length "+c+", got length="+t.length)}function j(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");A(t.outputLen),A(t.blockLen)}function v(t,c=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(c&&t.finished)throw new Error("Hash#digest() has already been called")}function M(t,c){b(t);const h=c.outputLen;if(t.length<h)throw new Error("digestInto() expects output buffer of length at least "+h)}function P(t){return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}function T(t){return new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4))}function U(...t){for(let c=0;c<t.length;c++)t[c].fill(0)}function p(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function F(t,c){return t<<32-c|t>>>c}function C(t,c){return t<<c|t>>>32-c>>>0}n.isLE=(()=>new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68)();function m(t){return t<<24&4278190080|t<<8&16711680|t>>>8&65280|t>>>24&255}n.swap8IfBE=n.isLE?t=>t:t=>m(t),n.byteSwapIfBE=n.swap8IfBE;function I(t){for(let c=0;c<t.length;c++)t[c]=m(t[c]);return t}n.swap32IfBE=n.isLE?t=>t:I;const S=(()=>typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function")(),X=Array.from({length:256},(t,c)=>c.toString(16).padStart(2,"0"));function H(t){if(b(t),S)return t.toHex();let c="";for(let h=0;h<t.length;h++)c+=X[t[h]];return c}const y={_0:48,_9:57,A:65,F:70,a:97,f:102};function E(t){if(t>=y._0&&t<=y._9)return t-y._0;if(t>=y.A&&t<=y.F)return t-(y.A-10);if(t>=y.a&&t<=y.f)return t-(y.a-10)}function s(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);if(S)return Uint8Array.fromHex(t);const c=t.length,h=c/2;if(c%2)throw new Error("hex string expected, got unpadded hex of length "+c);const d=new Uint8Array(h);for(let g=0,L=0;g<h;g++,L+=2){const W=E(t.charCodeAt(L)),K=E(t.charCodeAt(L+1));if(W===void 0||K===void 0){const z=t[L]+t[L+1];throw new Error('hex string expected, got non-hex character "'+z+'" at index '+L)}d[g]=W*16+K}return d}const o=async()=>{};n.nextTick=o;async function u(t,c,h){let d=Date.now();for(let g=0;g<t;g++){h(g);const L=Date.now()-d;L>=0&&L<c||(await(0,n.nextTick)(),d+=L)}}function f(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}function i(t){return new TextDecoder().decode(t)}function r(t){return typeof t=="string"&&(t=f(t)),b(t),t}function e(t){return typeof t=="string"&&(t=f(t)),b(t),t}function a(...t){let c=0;for(let d=0;d<t.length;d++){const g=t[d];b(g),c+=g.length}const h=new Uint8Array(c);for(let d=0,g=0;d<t.length;d++){const L=t[d];h.set(L,g),g+=L.length}return h}function w(t,c){if(c!==void 0&&{}.toString.call(c)!=="[object Object]")throw new Error("options should be object or undefined");return Object.assign(t,c)}class k{}n.Hash=k;function B(t){const c=d=>t().update(r(d)).digest(),h=t();return c.outputLen=h.outputLen,c.blockLen=h.blockLen,c.create=()=>t(),c}function V(t){const c=(d,g)=>t(g).update(r(d)).digest(),h=t({});return c.outputLen=h.outputLen,c.blockLen=h.blockLen,c.create=d=>t(d),c}function R(t){const c=(d,g)=>t(g).update(r(d)).digest(),h=t({});return c.outputLen=h.outputLen,c.blockLen=h.blockLen,c.create=d=>t(d),c}n.wrapConstructor=B,n.wrapConstructorWithOpts=V,n.wrapXOFConstructorWithOpts=R;function N(t=32){if(_.crypto&&typeof _.crypto.getRandomValues=="function")return _.crypto.getRandomValues(new Uint8Array(t));if(_.crypto&&typeof _.crypto.randomBytes=="function")return Uint8Array.from(_.crypto.randomBytes(t));throw new Error("crypto.getRandomValues must be defined")}}}]);
